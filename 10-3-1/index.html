<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10-3-1</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #166088;
            --accent-color: #4caf50;
            --light-bg: #f5f7fa;
            --dark-text: #333;
            --light-text: #fff;
            --border-radius: 8px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--light-bg);
            color: var(--dark-text);
            line-height: 1.6;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: var(--secondary-color);
            margin-bottom: 5px;
        }

        .header p {
            color: var(--dark-text);
            opacity: 0.8;
        }

        .game-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .target-container {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: var(--primary-color);
            color: var(--light-text);
            border-radius: var(--border-radius);
        }

        .target-container h2 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .target-container .target {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .tiles-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .tile {
            background-color: var(--secondary-color);
            color: var(--light-text);
            border-radius: var(--border-radius);
            padding: 15px 10px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tile.selected {
            background-color: var(--accent-color);
            transform: translateY(-3px);
        }

        .tile.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .selection-container {
            background-color: var(--light-bg);
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .current-selection {
            font-size: 1.8rem;
            font-weight: bold;
            min-height: 40px;
            margin-bottom: 10px;
        }

        .result {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-color);
            margin-top: 10px;
            min-height: 30px;
        }

        .buttons-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background-color: var(--primary-color);
            color: var(--light-text);
            border: none;
            border-radius: var(--border-radius);
            padding: 10px 15px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: var(--secondary-color);
        }

        button.danger {
            background-color: #e74c3c;
        }

        button.danger:hover {
            background-color: #c0392b;
        }

        .found-combinations {
            margin-top: 20px;
        }

        .found-combinations h3 {
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .combination-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        @media (max-width: 768px) {
            .combination-list {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 480px) {
            .combination-list {
                grid-template-columns: 1fr;
            }
            
            .tiles-container {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .combination-item {
            background-color: var(--light-bg);
            padding: 10px;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: bold;
        }

        .game-stats {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            max-width: 90%;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .modal-header h2 {
            color: var(--secondary-color);
        }

        .close-modal {
            font-size: 1.5rem;
            cursor: pointer;
        }

        .solution-list {
            margin-top: 15px;
        }

        .solution-item {
            background-color: var(--light-bg);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: var(--border-radius);
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            color: var(--dark-text);
            opacity: 0.7;
            font-size: 0.9rem;
        }

        .success-message {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background-color: var(--accent-color);
            color: white;
            border-radius: var(--border-radius);
            font-weight: bold;
            font-size: 1.2rem;
            display: none;
        }

        .game-selector {
            background: var(--primary-color);
            color: black;
            border: none;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            font-weight: bold;
            cursor: pointer;
            margin: 10px 0;
        }
        .game-selector:hover {
            background: var(--secondary-color);
        }
    </style>
</head>
<body>
    <select class="game-selector" onchange="location = this.value;">
        <option value="../">The French Connections</option>
        <option value="./index.html" selected>10-3-1</option>
    </select>
    <div class="header">
        <h1 data-translate="title">10-3-1</h1>
        <p data-translate="subtitle">Find all combinations of 3 tiles that equal the target number</p>
        <p id="date-display"></p>
    </div>

    <div class="game-container">
        <div class="target-container">
            <h2 data-translate="target">Target Number:</h2>
            <div class="target" id="target">0</div>
        </div>

        <div class="tiles-container" id="tiles-container">
            <!-- Tiles will be generated here -->
        </div>

        <div class="selection-container">
            <div class="current-selection" id="current-selection" data-translate="selectTiles">Select 3 tiles</div>
            <div class="result" id="result"></div>
        </div>

        <div class="buttons-container">
            <button id="clear-btn" data-translate="clearSelection">Clear Selection</button>
            <button id="hint-btn" data-translate="hint">Hint</button>
            <button id="surrender-btn" class="danger" data-translate="surrender">Surrender</button>
        </div>
        
        <div class="success-message" id="success-message" data-translate="congratulations">
            Congratulations! You found all possible combinations!
        </div>

        <div class="found-combinations">
            <h3 data-translate="foundCombinations">Found Combinations:</h3>
            <div class="combination-list" id="found-combinations-list">
                <!-- Found combinations will be added here -->
            </div>
        </div>
    </div>

    <div class="modal" id="solutions-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-translate="solutions">Solutions</h2>
                <span class="close-modal" id="close-modal">×</span>
            </div>
            <p data-translate="allSolutions">Here are all the possible combinations:</p>
            <div class="solution-list" id="solution-list">
                <!-- Solutions will be added here -->
            </div>
            <div class="buttons-container">
                <button id="new-game-btn" data-translate="newGame">New Game</button>
            </div>
        </div>
    </div>

    <div class="modal" id="tutorial-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 data-translate="howToPlay">How to Play</h2>
                <span class="close-modal" id="close-tutorial">×</span>
            </div>
            <div class="tutorial-content">
                <h3 data-translate="gameRules">Game Rules:</h3>
                <ol>
                    <li data-translate="rule1">Find combinations of 3 tiles that equal the target number</li>
                    <li data-translate="rule2">The operation on the first tile is ignored</li>
                    <li data-translate="rule3">Operations follow mathematical order (multiply/divide before add/subtract)</li>
                    <li data-translate="rule4">Example: If target is 9, selecting "-7", "+10", "/2" equals 7+10/2 = 7+5 = 12</li>
                    <li data-translate="rule5">Find all possible combinations to win!</li>
                </ol>
                <h3 data-translate="controls">Controls:</h3>
                <ul>
                    <li data-translate="control1">Click or press Enter on tiles to select them</li>
                    <li data-translate="control2">Use Tab to navigate between elements</li>
                    <li data-translate="control3">Use Hint button when stuck</li>
                    <li data-translate="control4">Clear selection to try again</li>
                </ul>
            </div>
            <div class="buttons-container">
                <button id="start-game-btn" data-translate="startPlaying">Start Playing</button>
            </div>
        </div>
    </div>

    <div class="footer">
        <p data-translate="footerText1">Each puzzle has at least one solution. Find them all!</p>
        <p data-translate="footerText2">A new puzzle is automatically generated each day.</p>
    </div>

    <div class="language-selector">
        <label for="language-select">Language:</label>
        <select id="language-select">
            <option value="en">English</option>
            <option value="fr">Français</option>
        </select>
    </div>

    <script>
        let gameState = {
            target: 0,
            tiles: [],
            selectedTiles: [],
            foundCombinations: [],
            allCombinations: [],
            gameDate: null
        };

        const targetDisplay = document.getElementById('target');
        const tilesContainer = document.getElementById('tiles-container');
        const currentSelection = document.getElementById('current-selection');
        const resultDisplay = document.getElementById('result');
        const clearBtn = document.getElementById('clear-btn');
        const hintBtn = document.getElementById('hint-btn');
        const surrenderBtn = document.getElementById('surrender-btn');
        const foundCombinationsList = document.getElementById('found-combinations-list');
        const solutionsModal = document.getElementById('solutions-modal');
        const closeModal = document.getElementById('close-modal');
        const solutionList = document.getElementById('solution-list');
        const newGameBtn = document.getElementById('new-game-btn');
        const successMessage = document.getElementById('success-message');
        const dateDisplay = document.getElementById('date-display');

        const translations = {
            en: {
                title: "10-3-1",
                subtitle: "Find all combinations of 3 tiles that equal the target number",
                target: "Target Number:",
                selectTiles: "Select 3 tiles",
                foundCombinations: "Found Combinations:",
                clearSelection: "Clear Selection",
                hint: "Hint",
                surrender: "Surrender",
                solutions: "Solutions",
                newGame: "New Game",
                howToPlay: "How to Play",
                gameRules: "Game Rules:",
                controls: "Controls:",
                startPlaying: "Start Playing",
                congratulations: "Congratulations! You found all possible combinations!",
                footerText1: "Each puzzle has at least one solution. Find them all!",
                footerText2: "A new puzzle is automatically generated each day.",
                allSolutions: "Here are all the possible combinations:",
                rule1: "Find combinations of 3 tiles that equal the target number",
                rule2: "The operation on the first tile is ignored",
                rule3: "Operations follow mathematical order (multiply/divide before add/subtract)",
                rule4: "Example: If target is 9, selecting \"-7\", \"+10\", \"/2\" equals 7+10/2 = 7+5 = 12",
                rule5: "Find all possible combinations to win!",
                control1: "Click or press Enter on tiles to select them",
                control2: "Use Tab to navigate between elements",
                control3: "Use Hint button when stuck",
                control4: "Clear selection to try again"
            },
            fr: {
                title: "10-3-1",
                subtitle: "Trouvez toutes les combinaisons de 3 tuiles qui égalent le nombre cible",
                target: "Nombre Cible:",
                selectTiles: "Sélectionnez 3 tuiles",
                foundCombinations: "Combinaisons Trouvées:",
                clearSelection: "Effacer la Sélection",
                hint: "Indice",
                surrender: "Abandonner",
                solutions: "Solutions",
                newGame: "Nouveau Jeu",
                howToPlay: "Comment Jouer",
                gameRules: "Règles du Jeu:",
                controls: "Contrôles:",
                startPlaying: "Commencer à Jouer",
                congratulations: "Félicitations! Vous avez trouvé toutes les combinaisons possibles!",
                footerText1: "Chaque puzzle a au moins une solution. Trouvez-les toutes!",
                footerText2: "Un nouveau puzzle est automatiquement généré chaque jour.",
                allSolutions: "Voici toutes les combinaisons possibles:",
                rule1: "Trouvez des combinaisons de 3 tuiles qui égalent le nombre cible",
                rule2: "L'opération sur la première tuile est ignorée",
                rule3: "Les opérations suivent l'ordre mathématique (multiplication/division avant addition/soustraction)",
                rule4: "Exemple: Si la cible est 9, sélectionner \"-7\", \"+10\", \"/2\" égale 7+10/2 = 7+5 = 12",
                rule5: "Trouvez toutes les combinaisons possibles pour gagner!",
                control1: "Cliquez ou appuyez sur Entrée sur les tuiles pour les sélectionner",
                control2: "Utilisez Tab pour naviguer entre les éléments",
                control3: "Utilisez le bouton Indice quand vous êtes bloqué",
                control4: "Effacez la sélection pour réessayer"
            }
        }

        // Initialize the game
        function initGame() {
            checkDateAndResetIfNeeded();
            setupLanguage();
            renderGame();
            setupEventListeners();
        }

        function setupLanguage() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlLang = urlParams.get('lang');
            const lang = urlLang || 'fr';
            const savedLang = localStorage.getItem('gameLanguage');
            
            const langSelect = document.getElementById('language-select');
            if (langSelect) {
                langSelect.value = lang;
                langSelect.addEventListener('change', (e) => {
                    const newLang = e.target.value;
                    localStorage.setItem('gameLanguage', newLang);
                    translate(newLang);
                });
            }
            
            translate(lang);
            localStorage.setItem('gameLanguage', lang);
        }

        function translate(lang) {
            document.querySelectorAll('[data-translate]').forEach(el => {
                el.textContent = translations[lang][el.dataset.translate];
            });
        }

        // Check if we need a new puzzle based on the date
        function checkDateAndResetIfNeeded() {
            const today = new Date();
            const dateString = `${today.getFullYear()}-${today.getMonth() + 1}-${today.getDate()}`;
            
            dateDisplay.textContent = today.toLocaleDateString(undefined, { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            
            // Check if we have a saved game
            const savedGame = localStorage.getItem('arithmeticPuzzle');
            
            if (savedGame) {
                const parsedGame = JSON.parse(savedGame);
                
                // If the game date matches today, load the saved game
                if (parsedGame.gameDate === dateString) {
                    gameState = parsedGame;
                    return;
                }
            }
            
            generateNewGame(dateString);
        }

        function generateNewGame(dateString) {
            let attempts = 0;
            let bestPuzzle = null;
            let bestScore = -1;
            
            console.log('Generating new puzzle...');
            
            // Try multiple puzzle generations and pick the best one
            while (attempts < 100) {
                const puzzle = generateSmartPuzzleCandidate();
                
                if (puzzle) {
                    const score = evaluatePuzzleQuality(puzzle);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestPuzzle = puzzle;
                    }
                    
                    // If we found a very good puzzle, use it
                    if (score >= 22) {
                        break;
                    }
                }
                
                attempts++;
            }
            
            //console.log(`Best puzzle found with score: ${bestScore} after ${attempts} attempts`);
            
            // If no good puzzle found, use fallback
            if (!bestPuzzle || bestScore < 5) {
                console.log('Using fallback puzzle generation');
                bestPuzzle = generateFallbackPuzzle();
            }
            
            // Reset game state with the new values
            gameState = {
                target: bestPuzzle.target,
                tiles: bestPuzzle.tiles,
                selectedTiles: [],
                foundCombinations: [],
                allCombinations: bestPuzzle.combinations,
                gameDate: dateString,
                puzzleQuality: bestPuzzle.quality || 'Standard'
            };
            
            // Save to localStorage
            localStorage.setItem('arithmeticPuzzle', JSON.stringify(gameState));
        }

        // Smart puzzle generation with operation probability based on number size
        function generateSmartPuzzleCandidate() {
            const numbers = generateSmartNumbers();
            
            const tiles = numbers.map(number => ({
                operation: selectSmartOperation(number),
                number: number
            }));
            
            const allResults = {};
            
            // Check all possible combinations of 3 tiles
            for (let i = 0; i < tiles.length; i++) {
                for (let j = 0; j < tiles.length; j++) {
                    if (j === i) continue;
                    
                    for (let k = 0; k < tiles.length; k++) {
                        if (k === i || k === j) continue;
                        
                        const combination = [tiles[i], tiles[j], tiles[k]];
                        const result = calculateResult(combination);
                        
                        if (result !== null && result >= 0 && result <= 20 && Number.isInteger(result)) {
                            const key = result.toString();
                            if (!allResults[key]) {
                                allResults[key] = [];
                            }
                            allResults[key].push({
                                indices: [i, j, k],
                                tiles: combination,
                                expression: formatExpression(combination)
                            });
                        }
                    }
                }
            }
            
            // Find targets with good combination counts and operation diversity
            const goodTargets = Object.keys(allResults).filter(targetStr => {
                const combinations = allResults[targetStr];
                const target = parseInt(targetStr);
                
                // Must have 2-6 combinations
                if (combinations.length < 1 || combinations.length > 7) return false;
                
                // Check for operation diversity
                const operations = new Set();
                combinations.forEach(combo => {
                    combo.tiles.forEach((tile, idx) => {
                        if (idx > 0) operations.add(tile.operation);
                    });
                });
                
                // Should have at least 3 different operations, preferably including * or /
                return operations.size >= 3 && (operations.has('*') || operations.has('/'));
            });
            
            if (goodTargets.length === 0) {
                return null;
            }
            
            const targetStr = selectBestTarget(goodTargets, allResults);
            const target = parseInt(targetStr);
            const combinations = allResults[targetStr];
            
            return {
                target,
                tiles,
                combinations,
            };
        }

        function generateSmartNumbers() {
            const numbers = [];
            
            // Ensure we have good mix of small and medium numbers
            // Small numbers (1-6): good for multiplication/division
            for (let i = 0; i < 4; i++) {
                numbers.push(Math.floor(Math.random() * 6) + 1);
            }
            
            // Medium numbers (4-12): versatile
            for (let i = 0; i < 4; i++) {
                numbers.push(Math.floor(Math.random() * 9) + 4);
            }
            
            // Larger numbers (8-20): mainly for addition/subtraction
            for (let i = 0; i < 2; i++) {
                numbers.push(Math.floor(Math.random() * 13) + 8);
            }
            
            // Shuffle the array
            shuffleArray(numbers);
            return numbers;
        }

        // Select operation based on numbers
        function selectSmartOperation(number) {
            const operations = ['+', '-', '*', '/'];
            
            if (number <= 4) {
                // Small numbers: favor multiplication and division
                const weights = [0.15, 0.15, 0.3, 0.4]; // +, -, *, /
                return selectWeightedOperation(operations, weights);
            } else if (number <= 8) {
                // Medium numbers: balanced
                const weights = [0.2, 0.2, 0.3, 0.3];
                return selectWeightedOperation(operations, weights);
            } else if (number <= 12) {
                // Medium-large numbers: slightly favor addition/subtraction
                const weights = [0.3, 0.3, 0.2, 0.2];
                return selectWeightedOperation(operations, weights);
            } else {
                // Large numbers: strongly favor addition/subtraction
                const weights = [0.3, 0.5, 0.05, 0.15];
                return selectWeightedOperation(operations, weights);
            }
        }

        // Select operation based on weights
        function selectWeightedOperation(operations, weights) {
            const random = Math.random();
            let cumulative = 0;
            
            for (let i = 0; i < operations.length; i++) {
                cumulative += weights[i];
                if (random <= cumulative) {
                    return operations[i];
                }
            }
            
            return operations[0];
        }

        // Select the best target based on operation diversity
        function selectBestTarget(targets, allResults) {
            let bestTarget = targets[0];
            let bestScore = -1;
            
            targets.forEach(targetStr => {
                const combinations = allResults[targetStr];
                let score = 0;
                
                // Count unique operations used
                const operations = new Set();
                combinations.forEach(combo => {
                    combo.tiles.forEach((tile, idx) => {
                        if (idx > 0) operations.add(tile.operation);
                    });
                });
                
                score += operations.size * 2; // Bonus for operation diversity
                
                // Bonus for having multiplication or division
                if (operations.has('*')) score += 3;
                if (operations.has('/')) score += 3;
                
                // Bonus for having both * and /
                if (operations.has('*') && operations.has('/')) score += 2;
                
                // Slight preference for 3-4 combinations
                if (combinations.length >= 3 && combinations.length <= 4) score += 1;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = targetStr;
                }
            });
            
            return bestTarget;
        }

        // Enhanced puzzle quality evaluation
        function evaluatePuzzleQuality(puzzle) {
            if (!puzzle) return -1;
            
            const combinations = puzzle.combinations;
            let score = 0;
            
            // Base score for combination count
            if (combinations.length >= 3 && combinations.length <= 4) {
                score += 3;
            } else if (combinations.length >= 2 && combinations.length <= 5) {
                score += 2;
            }
            
            // Analyze combinations diversity
            const operations = new Set();
            const numbers = new Set();
            combinations.forEach(combo => {
                combo.tiles.forEach((tile, idx) => {
                    if (idx > 0) {
                        operations.add(tile.operation);
                        numbers.add(tile.number);
                    }
                });
            });
            
            // Bonuses for operation diversity
            score += operations.size;
            if (operations.has('*')) score += 2;
            if (operations.has('/')) score += 2;
            if (operations.has('*') && operations.has('/')) score += 3;

            // Bonuses for numbers diversity
            score += numbers.size;
            
            return score;
        }

        // Fallback puzzle when smart generation fails
        function generateFallbackPuzzle() {
            const target = Math.floor(Math.random() * 15) + 5; // 5-19
            const tiles = [];
            
            // Create at least one simple solution
            tiles.push({ operation: '+', number: target - 2 });
            tiles.push({ operation: '+', number: 2 });
            tiles.push({ operation: '*', number: 1 });
            
            // Add one multiplication solution
            const factor = Math.floor(Math.random() * 4) + 2;
            if (target % factor === 0) {
                tiles.push({ operation: '+', number: 0 });
                tiles.push({ operation: '*', number: factor });
                tiles.push({ operation: '+', number: target / factor });
            }
            
            // Fill remaining tiles
            while (tiles.length < 10) {
                const operations = ['+', '-', '*', '/'];
                const number = Math.floor(Math.random() * 12) + 1;
                const operation = operations[Math.floor(Math.random() * operations.length)];
                tiles.push({ operation, number });
            }
            
            shuffleArray(tiles);
            
            return {
                target,
                tiles,
                combinations: findAllValidCombinations(target, tiles),
                quality: 'Fallback'
            };
        }

        function findAllValidCombinations(target, tiles) {
            const validCombinations = [];
            
            // Check all possible combinations of 3 tiles (it's not very costly in practice because there are only 720 combinations)
            for (let i = 0; i < tiles.length; i++) {
                for (let j = 0; j < tiles.length; j++) {
                    if (j === i) continue;
                    
                    for (let k = 0; k < tiles.length; k++) {
                        if (k === i || k === j) continue;
                        
                        const combination = [tiles[i], tiles[j], tiles[k]];
                        const result = calculateResult(combination);
                        
                        if (result === target) {
                            validCombinations.push({
                                indices: [i, j, k],
                                tiles: combination,
                                expression: formatExpression(combination)
                            });
                        }
                    }
                }
            }
            
            return validCombinations;
        }

        // Calculate the result of a combination
        function calculateResult(tiles) {
            let expression = tiles[0].number.toString();
            expression += tiles[1].operation + tiles[1].number.toString();
            expression += tiles[2].operation + tiles[2].number.toString();
            
            try {
                return eval(expression);
            } catch (e) {
                console.error("Error evaluating expression:", expression, e);
                return null;
            }
        }

        // Format expression for display
        function formatExpression(tiles) {
            return `${tiles[0].number} ${displayOperation(tiles[1].operation)} ${tiles[1].number} ${displayOperation(tiles[2].operation)} ${tiles[2].number} = ${calculateResult(tiles)}`;
        }

        function displayOperation(op) {
            if (op === '/') return '÷';
            if (op === '*') return '×';
            return op;
        }

        function renderGame() {
            targetDisplay.textContent = gameState.target;
            
            tilesContainer.innerHTML = '';
            gameState.tiles.forEach((tile, index) => {
                const tileElement = document.createElement('div');
                tileElement.className = 'tile';
                tileElement.dataset.index = index;
                tileElement.textContent = `${displayOperation(tile.operation)}${tile.number}`;               
                 tileElement.setAttribute('tabindex', '0');
                tileElement.setAttribute('role', 'button');
                tileElement.setAttribute('aria-label', `Tile ${tile.operation}${tile.number}`);
                tileElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        if (!e.target.classList.contains('disabled')) {
                            const index = parseInt(e.target.dataset.index);
                            selectTile(index, e.target);
                        }
                    }
                });
                tilesContainer.appendChild(tileElement);
            });
            
            renderFoundCombinations();
            
            // Check if all combinations are found
            if (gameState.foundCombinations.length > 0 && 
                gameState.foundCombinations.length === gameState.allCombinations.length) {
                successMessage.style.display = 'block';
            } else {
                successMessage.style.display = 'none';
            }
            
            // Clear the selection
            clearSelection();
        }

        // Render found combinations
        function renderFoundCombinations() {
            foundCombinationsList.innerHTML = '';
            
            gameState.foundCombinations.forEach(combination => {
                const combinationElement = document.createElement('div');
                combinationElement.className = 'combination-item';
                combinationElement.textContent = combination.expression;
                foundCombinationsList.appendChild(combinationElement);
            });
        }

        function setupEventListeners() {
            // Tile selection
            tilesContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('tile') && !e.target.classList.contains('disabled')) {
                    const index = parseInt(e.target.dataset.index);
                    selectTile(index, e.target);
                }
            });
            
            // Button events
            clearBtn.addEventListener('click', clearSelection);
            hintBtn.addEventListener('click', showHint);
            surrenderBtn.addEventListener('click', surrender);
            closeModal.addEventListener('click', () => {
                solutionsModal.style.display = 'none';
            });
            newGameBtn.addEventListener('click', () => {
                generateNewGame(new Date().toISOString().split('T')[0]);
                solutionsModal.style.display = 'none';
                renderGame();
            });
            
            // Close modal when clicking outside
            window.addEventListener('click', (e) => {
                if (e.target === solutionsModal) {
                    solutionsModal.style.display = 'none';
                }
            });

            [clearBtn, hintBtn, surrenderBtn, newGameBtn].forEach(btn => {
                btn.setAttribute('tabindex', '0');
            });

            // Listeners for the Tutorial Modal
            const tutorialModal = document.getElementById('tutorial-modal');
            const closeTutorial = document.getElementById('close-tutorial');
            const startGameBtn = document.getElementById('start-game-btn');
            const tutorialBtn = document.createElement('button');
            const lang = localStorage.getItem('gameLanguage') || 'fr';
            tutorialBtn.textContent = translations[lang].howToPlay || 'How to Play';
            tutorialBtn.id = 'tutorial-btn';
            document.querySelector('.buttons-container').appendChild(tutorialBtn);

            tutorialBtn.addEventListener('click', showTutorial);
            closeTutorial.addEventListener('click', () => {
                tutorialModal.style.display = 'none';
            });
            startGameBtn.addEventListener('click', () => {
                tutorialModal.style.display = 'none';
            });

            function showTutorial() {
                tutorialModal.style.display = 'flex';
            }

            // Don't show tutorial again if not first-time users
            if (!localStorage.getItem('tutorialSeen')) {
                window.addEventListener('DOMContentLoaded', () => {
                    setTimeout(showTutorial, 1000);
                    localStorage.setItem('tutorialSeen', 'true');
                });
            }
        }

        function selectTile(index, tileElement) {
            // If already 3 tiles selected, do nothing
            if (gameState.selectedTiles.length >= 3) return;
            
            gameState.selectedTiles.push({
                index,
                tile: gameState.tiles[index]
            });
            
            tileElement.classList.add('selected');
            tileElement.classList.add('disabled');
            
            updateSelectionDisplay();
            
            // If 3 tiles are selected, check if it's a valid combination
            if (gameState.selectedTiles.length === 3) {
                checkCombination();
            }
        }

        function updateSelectionDisplay() {
            if (gameState.selectedTiles.length === 0) {
                const lang = localStorage.getItem('gameLanguage') || 'fr';
                currentSelection.textContent = translations[lang].selectTiles || 'Select 3 tiles';
                resultDisplay.textContent = '';
                return;
            }
            
            const selectionText = gameState.selectedTiles.map(selected => {
                const tile = selected.tile;
                return `${tile.operation}${tile.number}`;
            }).join(' ');
            
            currentSelection.textContent = selectionText;
        }

        function checkCombination() {
            const selectedTileObjects = gameState.selectedTiles.map(selected => selected.tile);
            const result = calculateResult(selectedTileObjects);
            
            if (result === gameState.target) {
                // Valid combination
                const expression = formatExpression(selectedTileObjects);
                resultDisplay.textContent = `Correct! ${expression}`;
                resultDisplay.style.color = 'var(--accent-color)';
                
                // Check if this combination is already found
                const combinationIndices = gameState.selectedTiles.map(selected => selected.index);
                const alreadyFound = gameState.foundCombinations.some(combination => 
                    JSON.stringify(combination.indices) === JSON.stringify(combinationIndices)
                );
                
                if (!alreadyFound) {
                    gameState.foundCombinations.push({
                        indices: combinationIndices,
                        expression
                    });
                    
                    renderFoundCombinations();
                    
                    if (gameState.foundCombinations.length === gameState.allCombinations.length) {
                        successMessage.style.display = 'block';
                    }
                    
                    // Save game state
                    localStorage.setItem('arithmeticPuzzle', JSON.stringify(gameState));
                }
            } else {
                // Invalid combination
                resultDisplay.textContent = `Incorrect! Result: ${result}`;
                resultDisplay.style.color = '#e74c3c';
            }
        }

        function clearSelection() {
            gameState.selectedTiles = [];
            
            const selectedTiles = document.querySelectorAll('.tile.selected');
            selectedTiles.forEach(tile => {
                tile.classList.remove('selected');
                tile.classList.remove('disabled');
            });
            
            updateSelectionDisplay();
            resultDisplay.textContent = '';
        }

        function showHint() {
            const remainingCombinations = gameState.allCombinations.length - gameState.foundCombinations.length;
            alert(`There are ${remainingCombinations} combinations left to find.`);
        }

        // Surrender and show solutions
        function surrender() {
            // Display the solutions modal
            solutionsModal.style.display = 'flex';
            
            // Populate solution list
            solutionList.innerHTML = '';
            gameState.allCombinations.forEach(combination => {
                const solutionItem = document.createElement('div');
                solutionItem.className = 'solution-item';
                
                // Check if this solution was found by the player
                const found = gameState.foundCombinations.some(foundComb => 
                    JSON.stringify(foundComb.indices.sort()) === JSON.stringify(combination.indices.sort())
                );
                
                solutionItem.textContent = combination.expression;
                
                if (found) {
                    solutionItem.textContent += ' (Found)';
                    solutionItem.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                }
                
                solutionList.appendChild(solutionItem);
            });
        }

        // Utility function to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>